---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - convex/schema.ts
  - convex/sessions.ts
  - convex/participants.ts
  - convex/items.ts
  - convex/claims.ts
autonomous: true
---

<objective>
Create the Convex data schema and core queries/mutations for sessions, participants, items, and claims.

Purpose: Establish the data model that powers real-time bill splitting. Getting this right means all subsequent features (claiming, splitting, calculations) work naturally.

Output: Complete Convex schema with typed queries and mutations for session management, participant tracking, item management, and claim handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md

# Reference prior plan for Convex setup
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Convex schema for all data models</name>
  <files>convex/schema.ts</files>
  <action>
Create the complete schema for Split:

convex/schema.ts:
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Sessions represent a bill-splitting event
  sessions: defineTable({
    code: v.string(),                    // 6-char alphanumeric code for sharing
    hostName: v.string(),                // Display name of session creator
    createdAt: v.number(),               // Unix timestamp
    receiptImageId: v.optional(v.id("_storage")), // Convex file storage ID
    subtotal: v.optional(v.number()),    // Parsed from receipt
    tax: v.optional(v.number()),         // Parsed from receipt
    tipType: v.optional(v.union(
      v.literal("percent_subtotal"),     // Tip on subtotal only
      v.literal("percent_total"),        // Tip on subtotal + tax
      v.literal("manual")                // Manual dollar amount
    )),
    tipValue: v.optional(v.number()),    // Percentage or dollar amount
  })
    .index("by_code", ["code"]),         // Lookup sessions by share code

  // Participants are people in a session
  participants: defineTable({
    sessionId: v.id("sessions"),
    name: v.string(),                    // Display name
    isHost: v.boolean(),                 // Host has extra controls
    joinedAt: v.number(),                // Unix timestamp
  })
    .index("by_session", ["sessionId"]), // List participants in a session

  // Items are line items from the receipt
  items: defineTable({
    sessionId: v.id("sessions"),
    name: v.string(),                    // Item description
    price: v.number(),                   // Price in cents (avoid floating point)
    quantity: v.number(),                // Usually 1, but receipts may show "2 x $5.00"
  })
    .index("by_session", ["sessionId"]), // List items in a session

  // Claims link participants to items they're paying for
  claims: defineTable({
    sessionId: v.id("sessions"),         // Denormalized for efficient queries
    itemId: v.id("items"),
    participantId: v.id("participants"),
  })
    .index("by_session", ["sessionId"])  // All claims in a session
    .index("by_item", ["itemId"])        // Who claimed this item?
    .index("by_participant", ["participantId"]), // What did this person claim?
});
```

Key design decisions:
- **Prices in cents**: Avoids floating point issues (1299 instead of 12.99)
- **Denormalized sessionId in claims**: Enables efficient session-scoped queries
- **Separate claims table**: Supports multiple people claiming same item (split)
- **Optional receipt fields**: Session can exist before OCR completes
- **Tip types**: Matches PROJECT.md requirements (percent on subtotal, percent on total, manual)

AVOID: Don't add expiresAt yet - persistence strategy TBD. Don't add user authentication fields - anonymous sessions only.
  </action>
  <verify>
- `npx convex dev` syncs without schema errors
- Schema generates types in convex/_generated/
- No TypeScript errors when importing schema types
  </verify>
  <done>Complete Convex schema defined with sessions, participants, items, and claims tables.</done>
</task>

<task type="auto">
  <name>Task 2: Create session queries and mutations</name>
  <files>convex/sessions.ts</files>
  <action>
Create session management functions:

convex/sessions.ts:
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// Generate a random 6-character alphanumeric code
function generateCode(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Omit confusing chars (0/O, 1/I/L)
  let code = "";
  for (let i = 0; i < 6; i++) {
    code += chars[Math.floor(Math.random() * chars.length)];
  }
  return code;
}

// Get session by share code
export const getByCode = query({
  args: { code: v.string() },
  handler: async (ctx, args) => {
    const normalizedCode = args.code.toUpperCase().trim();
    return await ctx.db
      .query("sessions")
      .withIndex("by_code", (q) => q.eq("code", normalizedCode))
      .first();
  },
});

// Get session by ID
export const get = query({
  args: { id: v.id("sessions") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

// Create a new session
export const create = mutation({
  args: { hostName: v.string() },
  handler: async (ctx, args) => {
    // Generate unique code (retry if collision)
    let code = generateCode();
    let attempts = 0;
    while (attempts < 5) {
      const existing = await ctx.db
        .query("sessions")
        .withIndex("by_code", (q) => q.eq("code", code))
        .first();
      if (!existing) break;
      code = generateCode();
      attempts++;
    }

    const sessionId = await ctx.db.insert("sessions", {
      code,
      hostName: args.hostName.trim(),
      createdAt: Date.now(),
    });

    // Create host as first participant
    await ctx.db.insert("participants", {
      sessionId,
      name: args.hostName.trim(),
      isHost: true,
      joinedAt: Date.now(),
    });

    return { sessionId, code };
  },
});

// Update tip settings
export const updateTip = mutation({
  args: {
    sessionId: v.id("sessions"),
    tipType: v.union(
      v.literal("percent_subtotal"),
      v.literal("percent_total"),
      v.literal("manual")
    ),
    tipValue: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.sessionId, {
      tipType: args.tipType,
      tipValue: args.tipValue,
    });
  },
});

// Update receipt totals (called after OCR)
export const updateTotals = mutation({
  args: {
    sessionId: v.id("sessions"),
    subtotal: v.number(),
    tax: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.sessionId, {
      subtotal: args.subtotal,
      tax: args.tax,
    });
  },
});
```

AVOID: Don't add delete/archive yet. Don't validate hostName length extensively - keep simple.
  </action>
  <verify>
- `npx convex dev` syncs the functions
- Functions appear in Convex dashboard
- No TypeScript errors
  </verify>
  <done>Session queries and mutations created (get, getByCode, create, updateTip, updateTotals).</done>
</task>

<task type="auto">
  <name>Task 3: Create participant, item, and claim functions</name>
  <files>convex/participants.ts, convex/items.ts, convex/claims.ts</files>
  <action>
Create the remaining data access functions:

convex/participants.ts:
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// List all participants in a session
export const listBySession = query({
  args: { sessionId: v.id("sessions") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("participants")
      .withIndex("by_session", (q) => q.eq("sessionId", args.sessionId))
      .collect();
  },
});

// Join a session
export const join = mutation({
  args: {
    sessionId: v.id("sessions"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    const participantId = await ctx.db.insert("participants", {
      sessionId: args.sessionId,
      name: args.name.trim(),
      isHost: false,
      joinedAt: Date.now(),
    });
    return participantId;
  },
});

// Update participant name
export const updateName = mutation({
  args: {
    participantId: v.id("participants"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.participantId, {
      name: args.name.trim(),
    });
  },
});
```

convex/items.ts:
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// List all items in a session
export const listBySession = query({
  args: { sessionId: v.id("sessions") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("items")
      .withIndex("by_session", (q) => q.eq("sessionId", args.sessionId))
      .collect();
  },
});

// Add an item (from OCR or manual entry)
export const add = mutation({
  args: {
    sessionId: v.id("sessions"),
    name: v.string(),
    price: v.number(), // In cents
    quantity: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const itemId = await ctx.db.insert("items", {
      sessionId: args.sessionId,
      name: args.name.trim(),
      price: args.price,
      quantity: args.quantity ?? 1,
    });
    return itemId;
  },
});

// Update an item (fix OCR errors)
export const update = mutation({
  args: {
    itemId: v.id("items"),
    name: v.optional(v.string()),
    price: v.optional(v.number()),
    quantity: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const updates: Record<string, unknown> = {};
    if (args.name !== undefined) updates.name = args.name.trim();
    if (args.price !== undefined) updates.price = args.price;
    if (args.quantity !== undefined) updates.quantity = args.quantity;

    await ctx.db.patch(args.itemId, updates);
  },
});

// Delete an item
export const remove = mutation({
  args: { itemId: v.id("items") },
  handler: async (ctx, args) => {
    // Also delete all claims for this item
    const claims = await ctx.db
      .query("claims")
      .withIndex("by_item", (q) => q.eq("itemId", args.itemId))
      .collect();

    for (const claim of claims) {
      await ctx.db.delete(claim._id);
    }

    await ctx.db.delete(args.itemId);
  },
});

// Bulk add items (from OCR)
export const addBulk = mutation({
  args: {
    sessionId: v.id("sessions"),
    items: v.array(v.object({
      name: v.string(),
      price: v.number(),
      quantity: v.optional(v.number()),
    })),
  },
  handler: async (ctx, args) => {
    const itemIds = [];
    for (const item of args.items) {
      const itemId = await ctx.db.insert("items", {
        sessionId: args.sessionId,
        name: item.name.trim(),
        price: item.price,
        quantity: item.quantity ?? 1,
      });
      itemIds.push(itemId);
    }
    return itemIds;
  },
});
```

convex/claims.ts:
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// List all claims in a session (with item and participant details)
export const listBySession = query({
  args: { sessionId: v.id("sessions") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("claims")
      .withIndex("by_session", (q) => q.eq("sessionId", args.sessionId))
      .collect();
  },
});

// Get claims for a specific item
export const getByItem = query({
  args: { itemId: v.id("items") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("claims")
      .withIndex("by_item", (q) => q.eq("itemId", args.itemId))
      .collect();
  },
});

// Get claims for a specific participant
export const getByParticipant = query({
  args: { participantId: v.id("participants") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("claims")
      .withIndex("by_participant", (q) => q.eq("participantId", args.participantId))
      .collect();
  },
});

// Claim an item
export const claim = mutation({
  args: {
    sessionId: v.id("sessions"),
    itemId: v.id("items"),
    participantId: v.id("participants"),
  },
  handler: async (ctx, args) => {
    // Check if already claimed by this participant
    const existing = await ctx.db
      .query("claims")
      .withIndex("by_item", (q) => q.eq("itemId", args.itemId))
      .filter((q) => q.eq(q.field("participantId"), args.participantId))
      .first();

    if (existing) {
      return existing._id; // Already claimed, idempotent
    }

    return await ctx.db.insert("claims", {
      sessionId: args.sessionId,
      itemId: args.itemId,
      participantId: args.participantId,
    });
  },
});

// Unclaim an item
export const unclaim = mutation({
  args: {
    itemId: v.id("items"),
    participantId: v.id("participants"),
  },
  handler: async (ctx, args) => {
    const claim = await ctx.db
      .query("claims")
      .withIndex("by_item", (q) => q.eq("itemId", args.itemId))
      .filter((q) => q.eq(q.field("participantId"), args.participantId))
      .first();

    if (claim) {
      await ctx.db.delete(claim._id);
    }
  },
});
```

AVOID: Don't add complex business logic for splitting calculations - that's Phase 6. Don't add validation for "only host can..." - we're keeping permissive per PROJECT.md.
  </action>
  <verify>
- `npx convex dev` syncs all functions
- All functions appear in Convex dashboard under their respective modules
- No TypeScript errors
- API types generated correctly in convex/_generated/api.d.ts
  </verify>
  <done>All data access functions created for participants, items, and claims.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev` syncs without errors
- [ ] Schema creates all 4 tables with correct indexes
- [ ] All queries and mutations are accessible via api object
- [ ] TypeScript types are generated correctly
- [ ] Functions can be tested via Convex dashboard
- [ ] No runtime errors when calling functions
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Complete data layer for sessions, participants, items, claims
- Real-time queries ready for use in UI components
- Foundation supports all subsequent phase requirements
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
