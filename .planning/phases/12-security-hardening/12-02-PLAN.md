---
phase: 12-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [convex/sessions.ts, convex/items.ts]
autonomous: true
---

<objective>
Restrict session settings and destructive item operations to host only.

Purpose: Prevent non-host participants from modifying tax/tip settings or deleting items.
Output: Host-only authorization on session settings and destructive item mutations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-security-review/SECURITY-AUDIT.md

@convex/sessions.ts
@convex/items.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add host-only authorization to session settings mutations</name>
  <files>convex/sessions.ts</files>
  <action>
Add host verification to `updateTip`, `updateTax`, and `updateGratuity` mutations.

For each mutation:
- Add `participantId: v.id("participants")` parameter
- Query the participant record
- Verify participant exists and `isHost === true`
- Throw error "Only the host can modify bill settings" if not host
- Verify participant belongs to the same session being modified

Implementation pattern for each:
```typescript
args: {
  sessionId: v.id("sessions"),
  participantId: v.id("participants"),
  // ... existing args
},
handler: async (ctx, args) => {
  const participant = await ctx.db.get(args.participantId);
  if (!participant || !participant.isHost) {
    throw new Error("Only the host can modify bill settings");
  }
  if (participant.sessionId !== args.sessionId) {
    throw new Error("Participant not in this session");
  }
  // ... existing logic
}
```

Apply to: updateTip, updateTax, updateGratuity

Note: Keep `updateTotals` open - it's called after OCR and doesn't need host restriction (any participant can upload receipt per design).
  </action>
  <verify>TypeScript compiles: `npx convex dev --once`</verify>
  <done>updateTip, updateTax, updateGratuity require host participantId verification</done>
</task>

<task type="auto">
  <name>Task 2: Add authorization to destructive item mutations</name>
  <files>convex/items.ts</files>
  <action>
Add authorization to `remove` and `addBulk` mutations (destructive operations).

For `items.remove`:
- Add `participantId: v.id("participants")` parameter
- Query participant and verify isHost
- Throw error "Only the host can remove items" if not host
- Verify participant's session matches item's session

For `items.addBulk`:
- Add `participantId: v.id("participants")` parameter
- Query participant and verify isHost
- Throw error "Only the host can replace all items" if not host
- Verify participant's session matches args.sessionId

For `items.update`:
- Keep open (collaborative editing is intentional per design)
- But add session verification: query the item, verify item.sessionId matches a valid session
- This prevents updating items from non-existent sessions

For `items.add`:
- Keep open (any participant can add items per design)
- But add session verification: verify sessionId exists before inserting
  </action>
  <verify>TypeScript compiles: `npx convex dev --once`</verify>
  <done>remove and addBulk require host verification; add and update verify session exists</done>
</task>

<task type="auto">
  <name>Task 3: Update frontend to pass participantId for host-restricted mutations</name>
  <files>src/components/TaxTipSettings.tsx, src/components/ReceiptUpload.tsx, src/components/InlineItem.tsx</files>
  <action>
Update frontend components to pass participantId for the modified mutations.

For TaxTipSettings.tsx:
- Find usages of updateTip, updateTax, updateGratuity
- These should already be host-only in UI (isHost check)
- Add participantId parameter to each mutation call
- Get participantId from context/props (should be available from Bill page)

For ReceiptUpload.tsx (addBulk):
- Find where items.addBulk is called after OCR
- Add participantId parameter
- Get participantId from context/props

For InlineItem.tsx (remove):
- Find where items.remove is called (delete button)
- This should already be host-only in UI
- Add participantId parameter

Search for all usages:
- `useMutation(api.sessions.updateTip)`
- `useMutation(api.sessions.updateTax)`
- `useMutation(api.sessions.updateGratuity)`
- `useMutation(api.items.remove)`
- `useMutation(api.items.addBulk)`

Update each call site to pass the host's participantId.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors</verify>
  <done>All frontend calls to host-restricted mutations include participantId parameter</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev --once` succeeds
- [ ] `npm run build` succeeds
- [ ] Manual test: Host can modify tip/tax/gratuity settings
- [ ] Manual test: Non-host cannot modify settings (API call rejected)
- [ ] Manual test: Host can delete items
- [ ] Manual test: Non-host cannot delete items (API call rejected)
- [ ] Manual test: Host can use addBulk (re-upload receipt)
- [ ] Manual test: Non-host cannot use addBulk (API call rejected)
- [ ] Manual test: Any participant can still add single items
- [ ] Manual test: Any participant can still edit items
</verification>

<success_criteria>

- Session settings mutations require host verification
- Destructive item mutations (remove, addBulk) require host verification
- Non-destructive item mutations (add, update) verify session exists
- Frontend passes participantId correctly for all modified mutations
- No TypeScript errors
- Collaborative features (add, edit) still work for all participants
</success_criteria>

<output>
After completion, create `.planning/phases/12-security-hardening/12-02-SUMMARY.md`
</output>
