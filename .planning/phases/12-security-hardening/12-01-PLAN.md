---
phase: 12-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [convex/participants.ts, convex/claims.ts]
autonomous: true
---

<objective>
Fix HIGH priority authorization gaps in participant and claim mutations.

Purpose: Prevent users from modifying other users' names or removing other users' claims without authorization.
Output: Secured `updateName` and `unclaim` mutations with caller verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-security-review/SECURITY-AUDIT.md

@convex/participants.ts
@convex/claims.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add authorization to participants.updateName</name>
  <files>convex/participants.ts</files>
  <action>
Modify the `updateName` mutation to require a `callerParticipantId` parameter. Verify either:
1. The caller is updating their own name (`callerParticipantId === participantId`), OR
2. The caller is the host (`isHost === true` on the caller's participant record)

Implementation:
- Add `callerParticipantId: v.id("participants")` to args
- Query the caller's participant record
- Verify caller exists and is in the same session as the target participant
- Check if caller is updating self OR caller is host
- Throw error "Not authorized to update this participant" if neither condition is met
- Keep existing name trim logic

Also add case-insensitive duplicate name check (same as join mutation):
- Query all participants in session
- If new name matches another participant (case-insensitive), throw "That name is already taken"
  </action>
  <verify>TypeScript compiles without errors: `npx convex dev --once`</verify>
  <done>updateName requires callerParticipantId and verifies authorization before allowing name change</done>
</task>

<task type="auto">
  <name>Task 2: Add authorization to claims.unclaim</name>
  <files>convex/claims.ts</files>
  <action>
Modify the `unclaim` mutation to require a `callerParticipantId` parameter. Verify either:
1. The caller is unclaiming their own item (`callerParticipantId === participantId`), OR
2. The caller is the host (`isHost === true` on the caller's participant record)

Implementation:
- Add `callerParticipantId: v.id("participants")` to args
- Query the caller's participant record
- Check if caller is unclaiming self OR caller is host
- Throw error "Not authorized to unclaim for this participant" if neither condition is met
- Keep existing claim deletion logic

Note: The `unclaimByHost` mutation already exists with proper host verification. Consider whether it should be consolidated with `unclaim` or kept separate for clarity. Decision: Keep separate - `unclaim` for self-unclaim with optional host override, `unclaimByHost` explicitly for host managing others' claims.
  </action>
  <verify>TypeScript compiles without errors: `npx convex dev --once`</verify>
  <done>unclaim requires callerParticipantId and verifies authorization before allowing unclaim</done>
</task>

<task type="auto">
  <name>Task 3: Update frontend calls to pass callerParticipantId</name>
  <files>src/components/InlineItem.tsx, src/components/ParticipantName.tsx</files>
  <action>
Update frontend components that call the modified mutations to pass `callerParticipantId`.

For InlineItem.tsx (unclaim):
- The component already receives `myParticipantId` from the Bill page
- Update the unclaim mutation call to include `callerParticipantId: myParticipantId`
- Verify the unclaim button click handler passes this parameter

For ParticipantName.tsx (updateName) - if it exists:
- Find where updateName is called
- Pass the current user's participantId as callerParticipantId
- If component doesn't exist, search for updateName usage in codebase

Search for all usages:
- `useMutation(api.participants.updateName)`
- `useMutation(api.claims.unclaim)`

Update each call site to pass the caller's participantId.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors in frontend</verify>
  <done>All frontend calls to updateName and unclaim include callerParticipantId parameter</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev --once` succeeds (backend compiles)
- [ ] `npm run build` succeeds (frontend compiles)
- [ ] Manual test: User can update their own name
- [ ] Manual test: User cannot update another user's name (API call rejected)
- [ ] Manual test: User can unclaim their own item
- [ ] Manual test: User cannot unclaim another user's item (API call rejected)
- [ ] Manual test: Host can update any participant's name
- [ ] Manual test: Host can unclaim any participant's item
</verification>

<success_criteria>

- Both mutations require callerParticipantId parameter
- Authorization checks in place for both self-action and host-override cases
- Frontend passes callerParticipantId correctly
- No TypeScript errors
- Existing functionality preserved for authorized actions
</success_criteria>

<output>
After completion, create `.planning/phases/12-security-hardening/12-01-SUMMARY.md`
</output>
