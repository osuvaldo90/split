---
phase: 21-multiple-fees-taxes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/fees.ts
  - convex/participants.ts
autonomous: true

must_haves:
  truths:
    - "Fees table exists and accepts multiple fee records per session"
    - "Host can add, update, and remove fees"
    - "getTotals returns fee shares distributed proportionally to participants"
    - "Existing sessions with tax field continue to work (fallback)"
  artifacts:
    - path: "convex/schema.ts"
      provides: "fees table definition with sessionId index"
      contains: "fees: defineTable"
    - path: "convex/fees.ts"
      provides: "CRUD mutations for fees"
      exports: ["listBySession", "add", "addBulk", "update", "remove"]
    - path: "convex/participants.ts"
      provides: "Updated getTotals with fees support"
      contains: "fees.*withIndex"
  key_links:
    - from: "convex/fees.ts"
      to: "convex/schema.ts"
      via: "fees table reference"
      pattern: "fees.*sessionId"
    - from: "convex/participants.ts"
      to: "fees table"
      via: "query with fallback to tax"
      pattern: "fees\\.length === 0.*session\\.tax"
---

<objective>
Add fees table and CRUD operations, update calculation engine for multiple fees

Purpose: Enable storage and proportional distribution of multiple fee/tax line items per session, maintaining backward compatibility with existing sessions that use the single tax field.

Output: Working backend supporting multiple fees with proper distribution math
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-multiple-fees-taxes/21-CONTEXT.md
@.planning/phases/21-multiple-fees-taxes/21-RESEARCH.md

# Key files to reference
@convex/schema.ts
@convex/items.ts (pattern for CRUD)
@convex/participants.ts (getTotals to update)
@convex/calculations.ts (distributeWithRemainder)
@convex/validation.ts (validateMoney)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fees table and CRUD mutations</name>
  <files>
    convex/schema.ts
    convex/fees.ts
  </files>
  <action>
1. Update convex/schema.ts:
   - Add fees table with fields: sessionId (v.id("sessions")), label (v.string()), amount (v.number() in cents)
   - Add index "by_session" on sessionId
   - Keep existing tax field on sessions (do NOT remove - needed for backward compat)

2. Create convex/fees.ts following items.ts pattern:
   - listBySession query: Return all fees for a session
   - add mutation: Host-only, validate label (1-100 chars, trimmed) and amount (validateMoney)
   - addBulk mutation: Host-only, for OCR import, replaces existing fees for session (like items.addBulk)
   - update mutation: Host-only, update label and/or amount
   - remove mutation: Host-only, delete a fee

Validation rules:
- Label: 1-100 characters after trim, any printable characters allowed
- Amount: Use validateMoney from validation.ts (positive integer in cents)
- Max 50 fees per session in addBulk (reasonable limit)

Authorization: All mutations require participantId, verify isHost === true
  </action>
  <verify>
    - `npx convex dev` runs without schema errors
    - Check convex/schema.ts contains fees table with by_session index
    - Check convex/fees.ts exports listBySession, add, addBulk, update, remove
  </verify>
  <done>
    - Fees table defined in schema with sessionId index
    - All CRUD mutations implemented with host-only authorization
    - Validation matches items.ts patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Update getTotals for multiple fees with fallback</name>
  <files>
    convex/participants.ts
  </files>
  <action>
1. In getTotals query, after fetching session/participants/items/claims:
   - Query fees table for this session using by_session index
   - Calculate totalFees as sum of all fee amounts

2. Implement dual-read fallback:
   - If fees.length > 0: Use fees from table
   - If fees.length === 0 AND session.tax exists: Use session.tax as single fee
   - This ensures existing sessions continue working

3. Update fee distribution:
   - For each fee, call distributeWithRemainder(fee.amount, allSubtotals)
   - Sum each participant's share across all fees
   - Remove the unclaimed portion's share (same pattern as current tax)

4. Update return value:
   - Replace totalTax with totalFees (sum of all fees)
   - Keep returning individual participant.tax for now (will be renamed in UI plan)
   - Add fees array to return: { label: string, amount: number }[] for UI display

5. Handle gratuity separately (it's already in session.gratuity, not changing)
  </action>
  <verify>
    - `npx convex dev` compiles without errors
    - Grep participants.ts for: "fees" query, "fees.length === 0" fallback
    - Type check: return type includes fees array
  </verify>
  <done>
    - getTotals reads from fees table first, falls back to session.tax
    - Each fee distributed proportionally using distributeWithRemainder
    - Existing sessions with only tax field continue working identically
    - Return includes fees array for UI display
  </done>
</task>

</tasks>

<verification>
Run in sequence:
1. `npx convex dev` - Schema deploys, no TypeScript errors
2. Check schema.ts has fees table with index
3. Check fees.ts has all 5 exports (listBySession, add, addBulk, update, remove)
4. Check participants.ts getTotals has fees query with fallback logic
</verification>

<success_criteria>
- Fees table exists in Convex schema with sessionId index
- All fee CRUD mutations work (add, addBulk, update, remove) with host-only auth
- getTotals distributes multiple fees proportionally
- Existing sessions using tax field continue to work (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/21-multiple-fees-taxes/21-01-SUMMARY.md`
</output>
