---
phase: 14-access-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/Session.tsx
  - src/components/JoinGate.tsx
autonomous: true

must_haves:
  truths:
    - "Non-participant navigating to /bill/:code sees join prompt, not bill content"
    - "Participant with valid localStorage sees full bill content"
    - "Non-participant cannot see items, claims, or participant list"
  artifacts:
    - path: "src/components/JoinGate.tsx"
      provides: "Join prompt UI for non-participants"
      min_lines: 40
    - path: "src/pages/Session.tsx"
      provides: "Route-level gate checking participant status"
      contains: "JoinGate"
  key_links:
    - from: "Session.tsx"
      to: "JoinGate.tsx"
      via: "conditional render based on currentParticipantId"
      pattern: "currentParticipantId.*JoinGate"
---

<objective>
Implement route-level protection so non-participants see a join prompt instead of bill content.

Purpose: ACCESS-01 requires that users cannot view bill content at `/bill/:id` without first joining the session. They should see the bill exists and be prompted to join, but items/amounts stay hidden.

Output: JoinGate component that renders when user isn't a participant, Session.tsx gated to show content only after joining.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context
@.planning/phases/14-access-control/14-CONTEXT.md

# Current implementation
@src/pages/Session.tsx
@src/pages/Home.tsx
@src/lib/sessionStorage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JoinGate component</name>
  <files>src/components/JoinGate.tsx</files>
  <action>
Create a component that displays when a non-participant visits `/bill/:code`:
- Shows the session code prominently (they know they're at the right bill)
- Name input field (pre-fill from localStorage via getLastUsedName if available)
- "Join Bill" button that calls participants.join mutation
- On success: stores participant in localStorage (storeParticipant), adds to bill history, triggers parent callback
- On error: shows user-friendly error message (duplicate name, etc.)
- Loading state while joining
- Style consistently with Home.tsx join flow

Props interface:
```typescript
interface JoinGateProps {
  session: { _id: Id<"sessions">; code: string; hostName: string };
  onJoined: (participantId: Id<"participants">) => void;
}
```

Import from existing libs: getLastUsedName, setLastUsedName from userPreferences, storeParticipant from sessionStorage, addBillToHistory from billHistory.
  </action>
  <verify>npm run build succeeds, component file exists</verify>
  <done>JoinGate component created with name input, join button, error handling</done>
</task>

<task type="auto">
  <name>Task 2: Gate Session.tsx behind JoinGate</name>
  <files>src/pages/Session.tsx</files>
  <action>
Modify Session.tsx to conditionally render JoinGate when user isn't a participant:

1. After session loads and before rendering main content, check if `currentParticipantId` is null AND `storedParticipantId` is null (not just loading)
2. If no participant ID: render JoinGate instead of bill content
3. JoinGate receives session and onJoined callback
4. onJoined callback updates local state to trigger re-render with full content
5. Keep existing "Loading bill..." state for when session is undefined
6. Keep existing "Bill Not Found" state for when session is null

The gate should be inserted AFTER the session null checks, BEFORE the main content render. The key insight is:
- `storedParticipantId === null` means no localStorage entry
- `currentParticipant === undefined` means loading
- `currentParticipant === null` means localStorage entry was invalid
- Only show JoinGate when we're CERTAIN the user isn't a participant (storedParticipantId is null OR currentParticipant query returned null/mismatched)

Add useState for participantId override after joining so page updates immediately without page refresh.
  </action>
  <verify>npm run build succeeds, visiting /bill/CODE without localStorage shows join prompt</verify>
  <done>Session.tsx gates content behind participant check, shows JoinGate for non-participants</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] New user visiting /bill/VALIDCODE sees join prompt, not bill content
- [ ] After entering name and joining, full bill content appears
- [ ] Refreshing page after join shows bill content immediately (localStorage persists)
- [ ] Invalid code still shows "Bill Not Found" message
</verification>

<success_criteria>

- JoinGate component exists and renders for non-participants
- Session.tsx conditionally shows JoinGate or bill content
- Non-participants cannot see items, claims, or participant details
- Join flow works: enter name → join → see full content
- Existing participants (with localStorage) see content immediately
</success_criteria>

<output>
After completion, create `.planning/phases/14-access-control/14-01-SUMMARY.md`
</output>
