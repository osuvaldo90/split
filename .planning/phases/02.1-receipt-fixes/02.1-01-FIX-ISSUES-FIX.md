---
phase: 02.1-receipt-fixes
plan: 01-FIX-ISSUES
type: fix
wave: 1
depends_on: []
files_modified: [src/components/ItemEditor.tsx, src/components/ReceiptReview.tsx]
autonomous: true
---

<objective>
Fix 1 UAT blocker issue from plan 02.1-01-FIX.

Source: 02.1-01-FIX-ISSUES.md
Priority: 1 blocker (prevents users from entering decimal prices)

Purpose: Allow users to type decimal prices naturally without auto-formatting disrupting input.
Output: Price inputs format only on blur, not on every keystroke.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/02.1-receipt-fixes/02.1-01-FIX-ISSUES.md

**Original plan for reference:**
@.planning/phases/02.1-receipt-fixes/02.1-01-FIX.md
</context>

<tasks>
<task type="auto">
  <name>Task 1: Fix UAT-001 - Price input allows natural decimal entry</name>
  <files>src/components/ItemEditor.tsx, src/components/ReceiptReview.tsx</files>
  <action>
The root cause is `value={item.price.toFixed(2)}` which reformats on every keystroke.

**Solution approach - Format on blur, not on change:**

**ItemEditor.tsx changes:**
1. Add local state to track the raw input string during editing:
   - `const [priceInput, setPriceInput] = useState(item.price.toFixed(2))`
2. Sync local state when prop changes (user navigates between items):
   - Use useEffect to update priceInput when item.price changes externally
3. Change input value to use local state: `value={priceInput}`
4. onChange: Update local state with raw input (no formatting):
   - `setPriceInput(e.target.value.replace(/[^0-9.]/g, ''))`
5. onBlur: Parse and propagate to parent, then format for display:
   - Parse the value: `const parsed = parseFloat(priceInput) || 0`
   - Call onChange with parsed value: `onChange({ ...item, price: parsed })`
   - Format local state for display: `setPriceInput(parsed.toFixed(2))`
6. Keep onFocus select-all behavior

**ReceiptReview.tsx changes:**
Apply same pattern to subtotal and tax inputs:
1. Add local state for subtotal input string
2. Add local state for tax input string
3. Format on blur, not on change
4. Handle null case: empty string when null, parse to null when empty

**Important:** Must handle the case where price/subtotal/tax is updated externally (e.g., OCR scan replaces items). Use useEffect with dependency on the numeric value to sync local string state when prop changes.

**Do NOT:**
- Use onKeyDown to intercept keys (fragile, doesn't handle paste)
- Use cursor position manipulation (complex, error-prone)
- Add debouncing (unnecessary complexity)
  </action>
  <verify>
Manual test:
1. Start dev server: npm run dev
2. Navigate to item editing
3. Click a price field showing "6.00"
4. Type "5.45" - should show "5.45" while typing
5. Click away (blur) - should show "5.45" formatted
6. Type builds without errors: npm run build
  </verify>
  <done>
- User can type "5.45" naturally in price input
- Value formats to "X.XX" on blur (not on keystroke)
- Subtotal and tax inputs have same behavior
- No console errors or TypeScript errors
  </done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] Price input in ItemEditor allows typing decimals naturally
- [ ] Subtotal input in ReceiptReview allows typing decimals naturally
- [ ] Tax input in ReceiptReview allows typing decimals naturally
- [ ] All inputs format properly on blur
- [ ] Build passes: npm run build
- [ ] No TypeScript errors
</verification>

<success_criteria>
- UAT-001 from 02.1-01-FIX-ISSUES.md resolved
- User can type "5.45" in price field without cursor jumping
- Ready for re-verification via /gsd:verify-work
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-receipt-fixes/02.1-01-FIX-ISSUES-SUMMARY.md`
</output>
