---
phase: 05.1-fix-new-item-broadcast
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/pages/Session.tsx, src/components/ClaimableItem.tsx]
autonomous: true
---

<objective>
Fix new item broadcast by keeping draft items local until saved with actual content.

Purpose: Prevent empty items from appearing to other users when someone clicks "Add Item" - the item should only be broadcast after it has a name and price.
Output: Draft item functionality that stays local until saved, then syncs to all users.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-item-management/05-01-SUMMARY.md
@.planning/phases/05-item-management/05-02-SUMMARY.md
@.planning/phases/03.1-inline-item-editing/03.1-01-SUMMARY.md

@src/pages/Session.tsx
@src/components/ClaimableItem.tsx
@convex/items.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add local draft item state to Session page</name>
  <files>src/pages/Session.tsx</files>
  <action>
  Add local state to track a single draft item:

  1. Add state: `const [draftItem, setDraftItem] = useState<{ name: string; price: number; quantity: number } | null>(null);`

  2. Change "Add Item" button onClick to set local draft instead of calling mutation:
     ```
     onClick={() => setDraftItem({ name: "", price: 0, quantity: 1 })}
     ```
     Also disable button when draftItem is already present (only one draft at a time).

  3. Create handlers for draft item:
     - `handleDraftSave`: Call `addItem` mutation with draft data, then `setDraftItem(null)`
     - `handleDraftCancel`: Just `setDraftItem(null)`
     - `handleDraftChange`: Update draft state with new values

  4. Render draft item above the "Add Item" button (after regular items):
     - Only render if `draftItem !== null`
     - Pass draft data and handlers to a new draft-mode rendering
     - Use same ClaimableItem component but with `isDraft={true}` prop

  Note: Draft items are NOT in the database, so they have no _id. The ClaimableItem component will need to handle this case.
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>Session page has local draft state, Add Item creates local draft instead of DB record</done>
</task>

<task type="auto">
  <name>Task 2: Handle draft item rendering in ClaimableItem</name>
  <files>src/components/ClaimableItem.tsx</files>
  <action>
  Update ClaimableItem to support draft items that don't exist in DB yet:

  1. Extend props interface:
     ```typescript
     interface ClaimableItemProps {
       item: { ... };
       claims: Array<...>;
       participants: Array<...>;
       currentParticipantId: Id<"participants"> | null;
       isHost: boolean;
       // New props for draft mode
       isDraft?: boolean;
       onDraftSave?: (name: string, price: number, quantity: number) => void;
       onDraftCancel?: () => void;
       onDraftChange?: (name: string, price: number, quantity: number) => void;
     }
     ```

  2. For draft items (`isDraft === true`):
     - Always start in edit mode (don't allow view mode toggle)
     - On Save: call `onDraftSave` prop instead of `updateItem` mutation
     - On Cancel: call `onDraftCancel` prop instead of resetting to original values
     - On Delete: call `onDraftCancel` (same as cancel for drafts)
     - Disable claim interactions (no tap-to-claim for drafts)

  3. For regular items (`isDraft === false` or undefined):
     - Keep existing behavior unchanged
     - Use mutations as before

  4. The conditional logic in handleSave and handleCancel:
     ```typescript
     async function handleSave() {
       const priceInCents = Math.round(parseFloat(editPriceInput) * 100) || 0;

       if (isDraft && onDraftSave) {
         onDraftSave(editName, priceInCents, editQuantity);
       } else {
         await updateItem({
           itemId: item._id,
           name: editName,
           price: priceInCents,
           quantity: editQuantity,
         });
         setIsEditing(false);
       }
     }

     function handleCancel() {
       if (isDraft && onDraftCancel) {
         onDraftCancel();
       } else {
         setEditName(item.name);
         setEditPriceInput((item.price / 100).toFixed(2));
         setEditQuantity(item.quantity);
         setIsEditing(false);
       }
     }
     ```
  </action>
  <verify>
  Manual test:
  1. Open app in two browser windows with same session
  2. In window A, click "Add Item"
  3. Verify: Window B does NOT show any new item
  4. In window A, fill in name and price, click Save
  5. Verify: Window B now shows the new item
  6. Test cancel: Click "Add Item", then Cancel - verify no item created
  </verify>
  <done>Draft items stay local until saved, other users don't see empty items</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Draft item is NOT visible to other users until saved
- [ ] Saved item appears for all users via real-time sync
- [ ] Cancel removes draft without creating DB record
- [ ] Only one draft item allowed at a time
- [ ] Existing item edit functionality unchanged
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Empty items no longer broadcast to other users
- Draft→Save flow works correctly
- Draft→Cancel flow works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-fix-new-item-broadcast/05.1-01-SUMMARY.md`
</output>
