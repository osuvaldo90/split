---
phase: 19-e2e-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [e2e/join-flow.spec.ts]
autonomous: true

must_haves:
  truths:
    - "Guest can join an existing bill via session code"
    - "Guest can enter their display name"
    - "Guest can claim items in the session"
    - "Guest can see their updated total after claiming"
  artifacts:
    - path: "e2e/join-flow.spec.ts"
      provides: "Guest/join flow E2E tests"
      min_lines: 60
  key_links:
    - from: "hostContext"
      to: "guestContext"
      via: "Shared session code"
      pattern: "browser\\.newContext"
---

<objective>
Create E2E tests for the complete guest/join flow: join via code, enter name, claim items, view totals.

Purpose: Validate that guests can complete their user journey and interact with host-created bills.
Output: `e2e/join-flow.spec.ts` with tests covering E2E-05 through E2E-08.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-test-infrastructure/15-01-SUMMARY.md
@.planning/phases/19-e2e-tests/19-CONTEXT.md

@playwright.config.ts
@e2e/example.spec.ts
@src/pages/Home.tsx
@src/pages/Session.tsx
@src/components/JoinGate.tsx
@src/components/ClaimableItem.tsx
@src/components/Summary.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create join flow test with multi-context pattern</name>
  <files>e2e/join-flow.spec.ts</files>
  <action>
Create `e2e/join-flow.spec.ts` with Playwright tests for the guest flow using multi-context fixtures.

**Pattern:** Use Playwright's `browser` fixture to create two isolated browser contexts (host and guest) that simulate separate users on separate devices.

**Test structure:**
```typescript
import { test, expect } from '@playwright/test';

test.describe('Join Flow', () => {
  // Helper to create a bill and extract the code
  async function createBillAsHost(hostContext: any): Promise<{ page: any; code: string }> {
    const hostPage = await hostContext.newPage();
    await hostPage.goto('/');
    await hostPage.fill('input#name', 'Host');
    await hostPage.click('button:has-text("Start Bill")');
    await expect(hostPage).toHaveURL(/\/bill\/([A-Z0-9]{6})/);

    // Extract code from URL
    const url = hostPage.url();
    const match = url.match(/\/bill\/([A-Z0-9]{6})/);
    const code = match ? match[1] : '';
    expect(code).toHaveLength(6);

    return { page: hostPage, code };
  }

  test('E2E-05: guest can join via session code', async ({ browser }) => {
    // Create two isolated browser contexts
    const hostContext = await browser.newContext();
    const guestContext = await browser.newContext();

    try {
      // 1. Host creates a bill
      const { code } = await createBillAsHost(hostContext);

      // 2. Guest navigates to home
      const guestPage = await guestContext.newPage();
      await guestPage.goto('/');

      // 3. Guest enters the session code
      await guestPage.fill('input#code', code);

      // 4. Wait for "Bill found!" message
      await expect(guestPage.locator('text=Bill found!')).toBeVisible();

      // 5. Guest enters their name
      await guestPage.fill('input#name', 'Guest');

      // 6. Click "Join Bill"
      await guestPage.click('button:has-text("Join Bill")');

      // 7. Verify navigation to session page
      await expect(guestPage).toHaveURL(`/bill/${code}`);
    } finally {
      await hostContext.close();
      await guestContext.close();
    }
  });

  test('E2E-06: guest can enter display name', async ({ browser }) => {
    const hostContext = await browser.newContext();
    const guestContext = await browser.newContext();

    try {
      const { code } = await createBillAsHost(hostContext);

      const guestPage = await guestContext.newPage();
      // Navigate directly to bill URL without joining
      await guestPage.goto(`/bill/${code}`);

      // JoinGate should be shown
      await expect(guestPage.locator('text=Join this bill')).toBeVisible();

      // Enter name in JoinGate
      await guestPage.fill('input#join-name', 'Alice');

      // Click Join Bill
      await guestPage.click('button:has-text("Join Bill")');

      // Verify joined - should see the Items tab content
      await expect(guestPage.locator("text=Who's Here")).toBeVisible();

      // Verify Alice appears in participants list
      await expect(guestPage.locator('text=Alice')).toBeVisible();
    } finally {
      await hostContext.close();
      await guestContext.close();
    }
  });
});
```

**Key patterns:**
- Use `browser.newContext()` for isolated sessions (separate cookies, localStorage)
- Create helper function to reduce code duplication for bill creation
- Always close contexts in finally block to avoid leaks
- Extract code from URL after host creates bill
  </action>
  <verify>npx playwright test e2e/join-flow.spec.ts --grep "E2E-05|E2E-06" passes</verify>
  <done>Join via code and enter name tests pass with multi-context isolation</done>
</task>

<task type="auto">
  <name>Task 2: Add claim items and view totals tests</name>
  <files>e2e/join-flow.spec.ts</files>
  <action>
Add tests for E2E-07 and E2E-08 to the join flow spec.

**E2E-07: Guest can claim items**
```typescript
test('E2E-07: guest can claim items', async ({ browser }) => {
  const hostContext = await browser.newContext();
  const guestContext = await browser.newContext();

  try {
    // 1. Host creates bill and adds an item
    const { page: hostPage, code } = await createBillAsHost(hostContext);

    // Host adds an item
    await hostPage.click('button:has-text("+ Add Item")');
    await hostPage.fill('input[placeholder="Item name"]', 'Pizza');
    await hostPage.fill('input[inputmode="decimal"]', '15.00');
    await hostPage.click('button:has-text("Save")');
    await expect(hostPage.locator('text=Pizza')).toBeVisible();

    // 2. Guest joins the bill
    const guestPage = await guestContext.newPage();
    await guestPage.goto(`/bill/${code}`);
    await guestPage.fill('input#join-name', 'Bob');
    await guestPage.click('button:has-text("Join Bill")');

    // 3. Wait for items to load
    await expect(guestPage.locator('text=Pizza')).toBeVisible();

    // 4. Claim the item (click on it)
    await guestPage.click('text=Pizza');

    // 5. Verify claim indicator appears (Bob's name in claim pill)
    await expect(guestPage.locator('text=Bob').locator('..').locator('..')
      .filter({ has: guestPage.locator('text=Pizza') })).toBeVisible();

    // Alternative simpler verification: check for blue highlight on claimed item
    // The claimed item gets a blue-50 background and border-l-blue-500
    await expect(guestPage.locator('.bg-blue-50').filter({ hasText: 'Pizza' })).toBeVisible();
  } finally {
    await hostContext.close();
    await guestContext.close();
  }
});
```

**E2E-08: Guest can see updated totals after claiming**
```typescript
test('E2E-08: guest can see updated totals after claiming', async ({ browser }) => {
  const hostContext = await browser.newContext();
  const guestContext = await browser.newContext();

  try {
    // 1. Host creates bill and adds an item
    const { page: hostPage, code } = await createBillAsHost(hostContext);

    await hostPage.click('button:has-text("+ Add Item")');
    await hostPage.fill('input[placeholder="Item name"]', 'Pasta');
    await hostPage.fill('input[inputmode="decimal"]', '20.00');
    await hostPage.click('button:has-text("Save")');
    await expect(hostPage.locator('text=Pasta')).toBeVisible();

    // 2. Guest joins and claims
    const guestPage = await guestContext.newPage();
    await guestPage.goto(`/bill/${code}`);
    await guestPage.fill('input#join-name', 'Carol');
    await guestPage.click('button:has-text("Join Bill")');

    await expect(guestPage.locator('text=Pasta')).toBeVisible();
    await guestPage.click('text=Pasta');

    // 3. Navigate to Summary tab
    await guestPage.click('button:has-text("Summary")');

    // 4. Verify Carol's participant card shows with correct total
    await expect(guestPage.locator('text=Carol')).toBeVisible();

    // 5. Verify the total includes $20.00 (the claimed item)
    // Look for $20.00 in Carol's card
    const carolCard = guestPage.locator('div').filter({ hasText: 'Carol' }).first();
    await expect(carolCard.locator('text=/\\$20\\.00/')).toBeVisible();
  } finally {
    await hostContext.close();
    await guestContext.close();
  }
});
```

**Important patterns:**
- Each test creates fresh contexts - no state sharing between tests
- Host adds items BEFORE guest joins to ensure items are visible
- Use `locator.filter()` for scoped assertions within UI sections
- Summary tab shows participant totals in cards with name and amount
  </action>
  <verify>npx playwright test e2e/join-flow.spec.ts passes (all 4 tests)</verify>
  <done>All join flow tests pass: join, name, claim, totals</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx playwright test e2e/join-flow.spec.ts` passes all 4 tests
- [ ] Tests use browser contexts for proper isolation
- [ ] Tests run without flakiness (no random failures)
- [ ] No `waitForTimeout()` - use Playwright's auto-waiting
</verification>

<success_criteria>
- All tasks completed
- E2E-05, E2E-06, E2E-07, E2E-08 requirements satisfied
- Join flow tests pass reliably with multi-context pattern
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/19-e2e-tests/19-02-SUMMARY.md`
</output>
